#!/usr/bin/env python

'''
splitGenome.py

Split genome into pseudo reads based on split sites generated by junc2split.py
Designed by Peng Zhang on Apr. 2015
'''

import sys
import getopt
import gzip

use_message = '''

To be added.
'''

class Params:
  def __init__(self, num_threads = 1, rlen = 40, minrlen = 24, microrlen = 16, genome = '', outfile = ''):
    self.num_threads = num_threads
    self.rlen = rlen
    self.minrlen = minrlen
    self.microrlen = microrlen
    self.genome = genome
    self.outfile = outfile

  def parse_options(self, argv):
    try:
      opts, args = getopt.getopt(argv[1:], "hp:l:m:g:o:",["help", "num-threads=", "rlen=", "min-rlen=", "genome="])
    except:
      print(use_message)
      exit(1)

    self.args = args
    for option, value in opts:
      if option in ("-p", "--num-threads"):
        #print(option + value)
        self.num_threads = int(value)
      elif option in ("-h", "--help"):
        print(use_message)
        exit(1)
      elif option in ("-l", "--rlen") :
        self.rlen = int(value)
      elif option in ("-m", "--min-rlen") :
        self.minrlen = int(value)
      elif option in ("-g", "--genome") :
        self.genome = value
      elif option in ("-o") :
        self.outfile = value

    return args

  def check(self):
    if self.num_threads < 1 :
      die("Error: arg to --num-threads must be greater than 0")
    if self.genome == '':
      die("Genome fa file must be provided!")
    if self.outfile == '':
      die("Output file must be provided!")

def die(msg = None):
  if msg is not None:
    print >> sys.stderr, msg
#    if tophat_log:
#      print >> tophat_log, out_str
  sys.exit(1)

def fopen(filename):
  ns = filename.split('.')
  if ns[-1]=='gz' or ns[-1]=='gzip':
    fin = gzip.open(filename,'r')
  else:
    fin = open(filename,'r')
  return fin

def faIter(file):
  fin = fopen(file)
  id = ''
  for l in fin:
    l = l.strip()
    if l == '' : continue
    if l[0] == '>' :
      if id != '' :
        yield (id, seq)
      id = l[1:]
      seq = ''
    else:
      seq += l.upper()
  if id != '' : yield (id, seq)

class compRead:
  def __init__(self, chr = '', p0 = 0):
    self.nrBases = []
    self.baseReps = []
    self.p0 = p0
    self.p = p0
    self.chr = chr
    self.intrPos = []
    self.intrLen = []

  def seq(self):
    return ''.join(self.nrBases)

  def RNAlength(self):
    p = self.p - self.p0
    for l in self.intrLen:
      p -= l
    return p

  def length(self):
    return self.p - self.p0

  def __len__(self):
    return self.length()

  def compLen(self):
    return len(self.baseReps)

  def getBase(self, i):
    return self.nrBases[i], self.baseReps[i]

  def basePos(self, i):
    if i < 0: i += self.compLen()
    pr = 0
    ic = 0
    intr = 0
    for r in self.baseReps:
      if ic >= i : break
      ic += 1
      pr += r
      while intr < len(self.intrPos) and pr > self.intrPos[intr]:
        pr += self.intrLen[intr]
        intr += 1
    return pr + self.p0
  
  def __str__(self):
    return self.seq()
  
  def __repr__(self):
    s = "compRead object:\n"
    s += self.chr+":"+str(self.p0)+":"+str(self.length())+"\n"
    s += str(self) + "\n"
    s += str(self.baseReps)
    return  s
  
  def writeReads(self, rid = 0, fout = sys.stdout, contig = -1, strand = ''):
    cs = ''
    if contig >= 0:
      cs = str(contig) + '.'
    intrp = intrl = ''
    if len(self.intrPos) > 0 :
      intrp = " " + ','.join(map(str,self.intrPos))
      intrl = " " + ','.join(map(str,self.intrLen))
    fout.write(">"+cs+str(rid)+" "+self.chr+":"+str(self.p0)+":"+str(self.length())+strand+intrp+intrl+"\n")
    fout.write(self.seq()+"\n")

  def addBase(self, base, rep, gap = 0):
    if len(self.nrBases) == 0 or base != self.nrBases[-1]:
      self.nrBases.append(base)
      self.baseReps.append(rep)
    else:
      self.baseReps[-1] += rep
    if gap > 0 :
      self.intrPos.append(self.length())
      self.intrLen.append(gap)
    self.p += rep + gap
  
  def headBaseIter(self):
    if len(self.intrPos) == 0:
      for i in range(len(self.nrBases)):
        yield self.nrBases[i], self.baseReps[i], 0
    else:
      p = 0
      ini = 0
      for i in range(len(self.nrBases)):
        if ini >= len(self.intrPos) or p + self.baseReps[i] <= self.intrPos[ini]:
          yield self.nrBases[i], self.baseReps[i], 0 # Base, Rep, Gap
          p += self.baseReps[i]
        else:
          if self.intrPos[ini] > p:
            yield self.nrBases[i], self.intrPos[ini] - p, 0
          res = self.baseReps[i] - (self.intrPos[ini] - p)
          p = self.intrPos[ini]
          ini += 1
          while ini < len(self.intrPos) and p + res > self.intrPos[ini]:
            exLen = self.intrPos[ini] - self.intrPos[ini-1] - self.intrLen[ini-1]
            yield self.nrBases[i], exLen, self.intrLen[ini-1] 
            res -= exLen
            p = self.intrPos[ini]
            ini += 1
          yield self.nrBases[i], res, self.intrLen[ini-1]
          p += res + self.intrLen[ini-1]

      
  def trimBase(self):
    self.p -= self.baseReps[-1]
    self.nrBases[-1:] =[]
    self.baseReps[-1:] =[]
    while self.p <= self.intrPos[-1] + self.intrLen[-1]:
      self.p -= self.intrLen[-1]
      self.intrLen[-1:] = []
      self.intrPos[-1:] = []

  def headAddBase(self, base, rep, gap = 0):
    if base != self.nrBases[0]:
      self.nrBases[0:0] = [base]
      self.baseReps[0:0] = [rep]
    else:
      self.baseReps[0] += rep
    self.p0 -= rep + gap
    if gap > 0 :
      self.intrPos[0:0] = [0]
      self.intrLen[0:0] = [gap]
    for i in range(len(self.intrPos)):
      self.intrPos[i] += rep
  
  def leftExtend(self, read, elen):
    if read.p0 >= self.p0: return 1
    elif read.p < self.p0: return 1 # No gapped extention yet
    skip = read.p - self.p0
    i = read.compLen() - 1
    while i >= 0:
      if skip < read.baseReps[i]: break
      skip -= read.baseReps[i]
      i -= 1
    self.headAddBase(read.nrBases[i], read.baseReps[i] - skip)
    i -= 1
    while self.compLen() < elen and i >= 0:
      self.headAddBase(read.nrBases[i], read.baseReps[i])
      i -= 1
    if self.p0 != read.basePos(i+1): # Warning: introns not considered!
      sys.stderr.write('compRead.leftExtend: Position may be wrong!\n')
      sys.stderr.write(str(self.p0) + ' != ' + str(read.basePos(i)) + "\n")
      self.writeReads("self", sys.stderr)
      read.writeReads("extend", sys.stderr)
    return 0
        
    
class readArray:
  def __init__(self, chr, rlens = (40, 24, 16)):
    self.arr = []
    self.spls = []
    self.nr = 0
    #self.ns = 0
    self.chr = chr
    self.rlens = rlens
  
  def lastPos(self):
    if self.nr > 0 and len(self.arr[-1]) > 0: 
      return self.arr[-1][-1].p
    else : 
      return self.spls[-1][0][0]
    
  def addBase(self, base, rep): 
    #print 'addBase', self.spls, self.arr
    a = self.arr[len(self.spls) - 1]
    if len(a) == 0 :
      b = compRead(chr = self.chr, p0 = self.spls[-1][0][0])
      a.append(b)
      self.nr += 1
    elif a[-1].compLen() >= self.rlens[0]:
      #print 'addBase', a[-1].compLen , self.rlens[0]
      b = compRead(chr = self.chr, p0 = a[-1].p)
      a.append(b)
      self.nr += 1
    a[-1].addBase(base, rep)
    
  def addSpl(self, spl0, spl1): 
    self.spls.append([spl0, spl1])
    self.arr.append([])
    #print 'addSpl', self.spls, self.arr
  
  def checkReads(self): pass
  
  def export(self, fout, contig = -1, check = True, clear = True): 
    if check: self.checkReads()
    i = 0
    for a in self.arr:
      for r in a:
        r.writeReads(i, fout, contig)
        i += 1
    if clear: self.clear()
  
  def clear(self): 
    self.spls = []
    self.arr = []
    self.nr = 0
  
  def __len__(self):
    return len(self.spls)
    

#def findExtend(seq, p1, p2, rlens, chr, split_id, pi, fout):
#  rlen, minrlen = rlens

def repBaseIter(seq):
  i = 1
  last = ''
  for b in seq:
    if b == last: 
      i += 1
    elif last != '': 
      yield last, i
      i = 1
      last = b
    else: 
      last = b
  yield b, i

def splitGenome(argv = None, split = {}):
  params = Params()
  if argv is None:
    argv = sys.argv
  args = params.parse_options(argv)
  params.check()
  #print params.num_threads
  
  loadSpl(args, split)
  rlens = (params.rlen, params.minrlen, params.microrlen)
  fout = open(outfile, 'w')
  contig = 0
  for readarr in splitIter(params.genome, rlens, split):
    readarr.export(fout, contig)
    contig += 1

def loadSpl(files = [], split = {}):
  for f in files:
      fin = fopen(f)
      for l in fin:
        lst = l.strip().split()
        if lst[0] == '': lst[0] = last
        if lst[0] not in split: split[lst[0]] = {}
        split[lst[0]][int(lst[1])] = [int(lst[2]), lst[3]] #split[chr][pos]=[type,strand]
        last = lst[0]
  return split

def splitIter(genome, rlens = (40,24,16), split = {}):
  if split == {}:
    print('Warning: No split site input! Splice junctions will be ignored!')

  for chr, seq in faIter(genome): #
#    genome[chr] = seq
    length = len(seq)
    print chr + " ... " + str(length)
    readarr = readArray(chr, rlens)
    spls = [(0, (2, '+-'))]
    if chr in split:
      ps = split[chr].keys()
      ps.sort()
      for pos in ps:
        spls.append((pos, split[chr][pos]))
    spls.append((length, (2, '+-')))
    for i in range(len(spls) - 1):
      p1 = spls[i][0]
      p2 = spls[i+1][0]
      readarr.addSpl(spls[i], spls[i+1])
      for base, rep in repBaseIter(seq[p1:p2]):
        if base == 'N' and rep >= 10:
          newspl = (readarr.lastPos() + rep, (2, '+-'))
          #readarr.checkReads()
          if readarr.nr > 0: 
            readarr.spls[-1][1] = (readarr.lastPos(), (2, '+-'))
            yield readarr ##
          #readarr.export(fout, contig) #check, export, clear
          #readarr.clear()
          #contig += 1
          readarr = readArray(chr, rlens)
          readarr.addSpl(newspl, spls[i+1])
        else:
          readarr.addBase(base, rep)
    #readarr.checkReads()
    yield readarr
    #readarr.export(fout, contig)
    #contig += 1
    
          

if __name__ == '__main__':
  splitGenome()

